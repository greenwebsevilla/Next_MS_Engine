"""
ðŸ—ºï¸ Procesador de Mapas TMX - Pat Morita Team
VersiÃ³n: 1.1.1
---------------------------------------------
- AÃ±adido selector de idioma ES/EN (con texto EN en lugar de bandera).
- Todos los textos, etiquetas y mensajes de consola son traducibles.
- El idioma se guarda en config_protmx.txt.
"""

import os
import struct
import csv
import tkinter as tk
from tkinter import filedialog, messagebox
import xml.etree.ElementTree as ET

CONFIG_FILE = "config_protmx.txt"
VERSION = "1.1.1"

# ---------------- TEXTOS MULTILINGÃœES ----------------
TEXTS = {
    "es": {
        "title": f"ðŸ—ºï¸ Procesador de Mapas TMX Ver.{VERSION} (Pat Morita Team)",
        "src_label": "Carpeta de origen (mapas TMX):",
        "bin_label": "Carpeta de guardado BIN:",
        "map_check": "Generar tambiÃ©n archivos .MAP (Mappy)",
        "choose": "Elegir...",
        "process_btn": "Procesar mapas TMX",
        "exit_btn": "Salir",
        "help_btn": "Ayuda",
        "no_src": "Debes elegir la carpeta de origen (mapas TMX).",
        "no_bin": "Debes elegir la carpeta para guardar los BIN.",
        "no_map": "Debes elegir la carpeta para guardar los MAP.",
        "help_title": "Ayuda - Procesador TMX",
        "help_text": (
            "Instrucciones:\n\n"
            "- Este programa genera a partir de mapas creados con Tiled (tmx), ficheros binarios con la informaciÃ³n de los tiles que componen cada capa de los mapas. Procesa todos los mapas que encuentre en la carpeta de origen.\n\n"
            "- AdemÃ¡s, puedes crear un fichero .MAP con esta misma informaciÃ³n. Este fichero es equivalente al que genera el programa Mappy.\n\n"
            "- Puedes elegir las rutas donde guardar cada cosa y Ã©stas, se quedarÃ¡n almacenadas en el fichero de configuraciÃ³n del programa."
        ),
        "tooltip_empty": "(sin seleccionar)",
        "console_bin_saved": "âœ… BIN guardado:",
        "console_map_saved": "ðŸ—ºï¸ MAP guardado:",
        "console_done": "âœ… Procesamiento de mapas TMX completado."
    },
    "en": {
        "title": f"ðŸ—ºï¸ TMX Map Processor v{VERSION} (Pat Morita Team)",
        "src_label": "Source folder (TMX maps):",
        "bin_label": "BIN output folder:",
        "map_check": "Also generate .MAP files (Mappy)",
        "choose": "Choose...",
        "process_btn": "Process TMX maps",
        "exit_btn": "Exit",
        "help_btn": "Help",
        "no_src": "You must choose the source folder (TMX maps).",
        "no_bin": "You must choose the folder to save BIN files.",
        "no_map": "You must choose the folder to save MAP files.",
        "help_title": "Help - TMX Processor",
        "help_text": (
            "Instructions:\n\n"
            "- This program generates, from TMX maps created with Tiled, binary files containing the tile layer data. It processes all TMX files found in the source folder.\n\n"
            "- You can also create a .MAP file with the same information. This file is equivalent to the one generated by Mappy.\n\n"
            "- You can choose where to save each type of file, and these paths will be stored in the program configuration file."
        ),
        "tooltip_empty": "(not selected)",
        "console_bin_saved": "âœ… BIN saved:",
        "console_map_saved": "ðŸ—ºï¸ MAP saved:",
        "console_done": "âœ… TMX map processing completed."
    }
}

# ---------------- CONFIG ----------------
def load_config():
    config = {
        "source_path": "",
        "bin_path": "",
        "csv_path": "",
        "generate_csv": False,
        "lang": "es"
    }
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            for line in f:
                if "=" in line:
                    key, value = line.strip().split("=", 1)
                    if key in config:
                        if key == "generate_csv":
                            config[key] = value.lower() == "true"
                        else:
                            config[key] = value
    return config

def save_config(config):
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        for key, value in config.items():
            f.write(f"{key}={value}\n")

# ---------------- TMX PROCESSOR ----------------
def process_tmx_folder(source_folder, bin_folder, map_folder=None, generate_map=False, lang="es"):
    t = TEXTS[lang]
    if not generate_map:
        map_folder = None

    tmx_files = [f for f in os.listdir(source_folder) if f.lower().endswith(".tmx")]

    if not tmx_files:
        messagebox.showwarning("Aviso", t["no_src"])
        return

    for tmx_file in tmx_files:
        tmx_path = os.path.join(source_folder, tmx_file)
        tree = ET.parse(tmx_path)
        root = tree.getroot()

        for layer in root.findall("layer"):
            layer_name = layer.get("name")
            width = int(layer.get("width"))
            height = int(layer.get("height"))
            data_elem = layer.find("data")
            if data_elem is None or data_elem.text is None:
                continue
            data = data_elem.text.strip().replace("\n", "").replace("\r", "")
            tile_ids = [int(x) - 1 for x in data.split(",") if x != ""]

            os.makedirs(bin_folder, exist_ok=True)
            bin_filename = f"{os.path.splitext(tmx_file)[0]}_{layer_name}.bin"
            bin_path = os.path.join(bin_folder, bin_filename)
            with open(bin_path, "wb") as f:
                for tval in tile_ids:
                    f.write(struct.pack("B", tval if tval >= 0 else 0))
            print(f"{t['console_bin_saved']} {bin_path}")

            if map_folder:
                os.makedirs(map_folder, exist_ok=True)
                map_filename = f"{os.path.splitext(tmx_file)[0]}_{layer_name}.map"
                map_path = os.path.join(map_folder, map_filename)
                with open(map_path, "w", newline="", encoding="utf-8") as f:
                    writer = csv.writer(f)
                    for y in range(height):
                        row = tile_ids[y * width:(y + 1) * width]
                        writer.writerow(row)
                print(f"{t['console_map_saved']} {map_path}")

    print(t["console_done"])
    messagebox.showinfo("OK", t["console_done"])

# ---------------- GUI ----------------
class TMXProcessorGUI:
    def __init__(self, root):
        self.root = root
        self.config = load_config()
        self.lang = self.config.get("lang", "es")
        self.root.title(self.t("title"))
        self.root.minsize(620, 370)

        # --- Selector de idioma ---
        lang_frame = tk.Frame(root)
        lang_frame.pack(anchor="ne", padx=10, pady=5)
        es_btn = tk.Button(lang_frame, text="ES", command=lambda: self.set_lang("es"))
        en_btn = tk.Button(lang_frame, text="EN", command=lambda: self.set_lang("en"))
        es_btn.pack(side="left", padx=2)
        en_btn.pack(side="left", padx=2)

        # --- Carpetas ---
        self.src_title = tk.Label(root, text=self.t("src_label"))
        self.src_title.pack(anchor="w", padx=10, pady=(5,0))
        self.src_label, self.src_button = self._path_selector(self.config["source_path"], self.choose_source_path)

        self.bin_title = tk.Label(root, text=self.t("bin_label"))
        self.bin_title.pack(anchor="w", padx=10, pady=(5,0))
        self.bin_label, self.bin_button = self._path_selector(self.config["bin_path"], self.choose_bin_path)

        # --- MAP ---
        self.generate_map_var = tk.BooleanVar(value=self.config["generate_csv"])
        self.map_check = tk.Checkbutton(root, text=self.t("map_check"),
                                        variable=self.generate_map_var, command=self.toggle_map)
        self.map_check.pack(anchor="w", padx=10, pady=(5,0))
        self.map_label, self.map_button = self._path_selector(self.config["csv_path"], self.choose_map_path,
                                                              state="normal" if self.generate_map_var.get() else "disabled")

        # --- Botones finales ---
        btn_frame = tk.Frame(root)
        btn_frame.pack(fill="x", pady=15)
        self.process_btn = tk.Button(btn_frame, text=self.t("process_btn"), command=self.run_processing)
        self.process_btn.pack(side="left", padx=5)
        self.exit_btn = tk.Button(btn_frame, text=self.t("exit_btn"), command=root.quit)
        self.exit_btn.pack(side="left", padx=5)
        self.help_btn = tk.Button(btn_frame, text=self.t("help_btn"), command=self.show_help)
        self.help_btn.pack(side="right", padx=5)

    # --------- Helpers GUI ----------
    def t(self, key):
        return TEXTS[self.lang].get(key, key)

    def set_lang(self, lang):
        self.lang = lang
        self.config["lang"] = lang
        save_config(self.config)
        self.refresh_texts()

    def refresh_texts(self):
        self.root.title(self.t("title"))
        self.src_title.config(text=self.t("src_label"))
        self.bin_title.config(text=self.t("bin_label"))
        self.map_check.config(text=self.t("map_check"))
        self.process_btn.config(text=self.t("process_btn"))
        self.exit_btn.config(text=self.t("exit_btn"))
        self.help_btn.config(text=self.t("help_btn"))
        self.src_button.config(text=self.t("choose"))
        self.bin_button.config(text=self.t("choose"))
        self.map_button.config(text=self.t("choose"))

    def _path_selector(self, initial_path, choose_callback, state="normal"):
        frame = tk.Frame(self.root)
        frame.pack(fill="x", padx=10)
        btn = tk.Button(frame, text=self.t("choose"), command=choose_callback, state=state)
        btn.pack(side="left")
        label = tk.Label(frame, text=self.short_path(initial_path), fg="blue")
        label.pack(side="left", padx=10)
        self.add_tooltip(label, initial_path)
        return label, btn

    def short_path(self, path):
        if not path:
            return self.t("tooltip_empty")
        norm = os.path.normpath(path)
        parts = norm.split(os.sep)
        if len(parts) > 3:
            return "..." + os.sep + os.path.join(*parts[-3:])
        else:
            return norm

    def add_tooltip(self, widget, text):
        if not text:
            return
        tooltip = tk.Toplevel(widget)
        tooltip.withdraw()
        tooltip.overrideredirect(True)
        tooltip_label = tk.Label(tooltip, text=text, bg="#ffffe0", relief="solid", borderwidth=1, padx=4, pady=2)
        tooltip_label.pack()

        def enter(event):
            tooltip_label.config(text=text)
            tooltip.deiconify()
            x = event.x_root + 10
            y = event.y_root + 10
            tooltip.geometry(f"+{x}+{y}")

        def leave(event):
            tooltip.withdraw()

        widget.bind("<Enter>", enter)
        widget.bind("<Leave>", leave)

    # --- Carpeta handlers ---
    def choose_source_path(self):
        folder = filedialog.askdirectory(title=self.t("src_label"))
        if folder:
            self.config["source_path"] = folder
            self.src_label.config(text=self.short_path(folder))
            self.add_tooltip(self.src_label, folder)
            save_config(self.config)

    def choose_bin_path(self):
        folder = filedialog.askdirectory(title=self.t("bin_label"))
        if folder:
            self.config["bin_path"] = folder
            self.bin_label.config(text=self.short_path(folder))
            self.add_tooltip(self.bin_label, folder)
            save_config(self.config)

    def choose_map_path(self):
        folder = filedialog.askdirectory(title="MAP folder")
        if folder:
            self.config["csv_path"] = folder
            self.map_label.config(text=self.short_path(folder))
            self.add_tooltip(self.map_label, folder)
            save_config(self.config)

    def toggle_map(self):
        enabled = self.generate_map_var.get()
        self.map_button.config(state="normal" if enabled else "disabled")
        if enabled:
            stored_path = self.config.get("csv_path", "").strip()
            if stored_path:
                self.map_label.config(text=self.short_path(stored_path))
                self.add_tooltip(self.map_label, stored_path)
            else:
                self.map_label.config(text=self.t("tooltip_empty"))
        else:
            self.map_label.config(text=self.t("tooltip_empty"))
        self.config["generate_csv"] = enabled
        save_config(self.config)

    def run_processing(self):
        source_path = self.config["source_path"].strip()
        bin_path = self.config["bin_path"].strip()
        generate_map = self.generate_map_var.get()
        map_path = self.config["csv_path"].strip() if generate_map else None

        if not source_path:
            messagebox.showerror("Error", self.t("no_src"))
            return
        if not bin_path:
            messagebox.showerror("Error", self.t("no_bin"))
            return
        if generate_map and not map_path:
            messagebox.showerror("Error", self.t("no_map"))
            return

        self.config["generate_csv"] = generate_map
        save_config(self.config)

        process_tmx_folder(source_path, bin_path, map_path, generate_map, self.lang)

    def show_help(self):
        messagebox.showinfo(self.t("help_title"), self.t("help_text"))

# ---------------- MAIN ----------------
if __name__ == "__main__":
    root = tk.Tk()
    app = TMXProcessorGUI(root)
    root.mainloop()
