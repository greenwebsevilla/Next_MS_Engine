"""
üó∫Ô∏è Procesador de Mapas TMX - Pat Morita Team
Versi√≥n: 1.2.1
---------------------------------------------
- A√±adida exporataci√≥n de capas de objetos para enemigos.
"""

import os
import struct
import csv
import tkinter as tk
from tkinter import filedialog, messagebox
import xml.etree.ElementTree as ET

CONFIG_FILE = "config_protmx.txt"
VERSION = "1.2.1"

# ---------------- TEXTOS MULTILING√úES ----------------
TEXTS = {
    "es": {
        "title": f"NMSE - Procesador de Mapas TMX Ver.{VERSION} (Pat Morita Team)",
        "src_label": "Carpeta de origen (mapas TMX):",
        "bin_label": "Carpeta de guardado BIN:",
        "map_check": "Generar tambi√©n archivos .MAP (Mappy)",
        "choose": "Elegir...",
        "process_btn": "Procesar mapas TMX",
        "exit_btn": "Salir",
        "help_btn": "Ayuda",
        "no_src": "Debes elegir la carpeta de origen (mapas TMX).",
        "no_bin": "Debes elegir la carpeta para guardar los BIN.",
        "no_map": "Debes elegir la carpeta para guardar los MAP.",
        "help_title": "Ayuda - Procesador TMX",
        "help_text": (
            "Instrucciones:\n\n"
            "- Este programa genera a partir de mapas creados con Tiled (tmx) ficheros binarios con la informaci√≥n de los tiles que componen los mapas: 'nombre_tiles.bin'. Procesa todos los mapas que encuentre en la carpeta de origen.\n"
            "Si el mapa contiene una capa de objetos con la informaci√≥n de los enemigos (capa enemies), se generar√° tambi√©n un binario con esa informaci√≥n: 'nombre_enemies.bin'\n\n"
            "- Adem√°s, puedes crear un fichero .MAP con esta misma informaci√≥n. Este fichero es equivalente al que genera el programa Mappy.\n\n"
            "- Puedes elegir las rutas donde guardar cada cosa y √©stas, se quedar√°n almacenadas en el fichero de configuraci√≥n del programa."
        ),
        "tooltip_empty": "(sin seleccionar)",
        "console_bin_saved": "‚úÖ BIN guardado:",
        "console_map_saved": "üó∫Ô∏è MAP guardado:",
        "console_done": "‚úÖ Procesamiento de mapas TMX completado."
    },
    "en": {
        "title": f"NMSE - TMX Map Processor v{VERSION} (Pat Morita Team)",
        "src_label": "Source folder (TMX maps):",
        "bin_label": "BIN output folder:",
        "map_check": "Also generate .MAP files (Mappy)",
        "choose": "Choose...",
        "process_btn": "Process TMX maps",
        "exit_btn": "Exit",
        "help_btn": "Help",
        "no_src": "You must choose the source folder (TMX maps).",
        "no_bin": "You must choose the folder to save BIN files.",
        "no_map": "You must choose the folder to save MAP files.",
        "help_title": "Help - TMX Processor",
        "help_text": (
            "Instructions:\n\n"
            "- This program generates, from TMX maps created with Tiled, binary files containing the tile layer data: 'name_tiles.bin'. It processes all TMX files found in the source folder.\n"
            "If the map contains an object layer with enemy information ('enemies' layer), a binary file with that data will also be generated: 'name_enemies.bin'\n\n"
            "- You can also create a .MAP file with the same information. This file is equivalent to the one generated by Mappy.\n\n"
            "- You can choose where to save each type of file, and these paths will be stored in the program configuration file."
        ),
        "tooltip_empty": "(not selected)",
        "console_bin_saved": "‚úÖ BIN saved:",
        "console_map_saved": "üó∫Ô∏è MAP saved:",
        "console_done": "‚úÖ TMX map processing completed."
    }
}

# ---------------- CONFIG ----------------
def load_config():
    config = {
        "source_path": "",
        "bin_path": "",
        "csv_path": "",
        "generate_csv": False,
        "lang": "es"
    }
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            for line in f:
                if "=" in line:
                    key, value = line.strip().split("=", 1)
                    if key in config:
                        if key == "generate_csv":
                            config[key] = value.lower() == "true"
                        else:
                            config[key] = value
    return config

def save_config(config):
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        for key, value in config.items():
            f.write(f"{key}={value}\n")
 
# ---------------- TMX PROCESSOR ----------------
def process_tmx_folder(source_folder, bin_folder, map_folder=None, generate_map=False, lang="es"):
    t = TEXTS[lang]
    if not generate_map:
        map_folder = None

    TILE_SIZE = 16  # <-- ajusta si tu engine usa otro tama√±o de tile

    tmx_files = [f for f in os.listdir(source_folder) if f.lower().endswith(".tmx")]

    if not tmx_files:
        messagebox.showwarning("Aviso", t["no_src"])
        return

    for tmx_file in tmx_files:
        tmx_path = os.path.join(source_folder, tmx_file)
        tree = ET.parse(tmx_path)
        root = tree.getroot()
        base_name = os.path.splitext(tmx_file)[0]

        # --------------------------------------------------------
        # 1) Construir diccionario de marcadores de _temp_markers
        #    markers = { id:int  ->  (tileX:uint8, tileY:uint8) }
        # --------------------------------------------------------
        markers = {}
        markers_layer = root.find("objectgroup[@name='_temp_markers']")
        if markers_layer is not None:
            for mobj in markers_layer.findall("object"):
                try:
                    mid = int(mobj.get("id"))
                    # x,y vienen en p√≠xeles; convertimos a coordenadas de tile
                    # Usamos floor (int) y forzamos a rango 0..255
                    mx = int(float(mobj.get("x", "0")) // TILE_SIZE) % 256
                    my = int(float(mobj.get("y", "0")) // TILE_SIZE) % 256
                    markers[mid] = (mx, my)
                except Exception:
                    # si algo va mal con un marcador, lo ignoramos
                    pass

        # -------------------
        # 2) CAPAS DE TILES
        # -------------------
        for layer in root.findall("layer"):
            layer_name = layer.get("name")
            if layer_name == "_temp_markers":
                continue  # ‚ùå Ignorar esta capa especial

            width = int(layer.get("width"))
            height = int(layer.get("height"))
            data_elem = layer.find("data")
            if data_elem is None or data_elem.text is None:
                continue
            data = data_elem.text.strip().replace("\n", "").replace("\r", "")
            tile_ids = [int(x) - 1 for x in data.split(",") if x != ""]

            # --- BIN ---
            os.makedirs(bin_folder, exist_ok=True)
            bin_filename = f"{base_name}_tiles.bin"
            bin_path = os.path.join(bin_folder, bin_filename)
            with open(bin_path, "wb") as f:
                # Escribir ancho y alto del mapa como los dos primeros bytes (uint8)
                f.write(struct.pack("BB", width % 256, height % 256))

                # Escribir los tiles (uno por byte)
                for tval in tile_ids:
                    f.write(struct.pack("B", tval if tval >= 0 else 0))
                    
            print(f"{t['console_bin_saved']} {bin_path}  ({width}x{height})")

            # --- MAP ---
            if map_folder:
                os.makedirs(map_folder, exist_ok=True)
                map_filename = f"{base_name}_{layer_name}.map"
                map_path = os.path.join(map_folder, map_filename)
                with open(map_path, "w", newline="", encoding="utf-8") as f:
                    writer = csv.writer(f)
                    for y in range(height):
                        row = tile_ids[y * width:(y + 1) * width]
                        writer.writerow(row)
                print(f"{t['console_map_saved']} {map_path}")

        # --------------------------------------------------
        # 3) CAPA DE ENEMIGOS (con referencias limitA/limitB)
        #    Formato por enemigo (12 bytes, todos uint8):
        #    spawnX,spawnY,limit1X,limit1Y,limit2X,limit2Y,
        #    velocidad_x,velocidad_y,tipo,num_pantalla,enem_life,sprite
        #    Primer byte del archivo = n√∫mero total de enemigos
        # --------------------------------------------------
        enemies_layer = root.find("objectgroup[@name='enemies']")
        if enemies_layer is not None:
            enemies_bin_filename = f"{base_name}_enemies.bin"
            enemies_bin_path = os.path.join(bin_folder, enemies_bin_filename)
            os.makedirs(bin_folder, exist_ok=True)

            with open(enemies_bin_path, "wb") as f:
                # Reservamos primer byte para el contador
                f.write(struct.pack("B", 0))
                enemy_count = 0

                for obj in enemies_layer.findall("object"):
                    # Extraer propiedades personalizadas en dict {name: value(str)}
                    props = {}
                    props_elem = obj.find("properties")
                    if props_elem is not None:
                        for p in props_elem.findall("property"):
                            name = p.get("name")
                            # En Tiled, las propiedades pueden venir con distintos atributos (value, type, etc.)
                            # intentamos primero 'value'; si no est√°, usamos el texto o 0.
                            val = p.get("value")
                            if val is None:
                                val = p.text if p.text is not None else "0"
                            if name:
                                props[name] = val

                    def get_int(name, default=0):
                        try:
                            return int(props.get(name, default))
                        except (TypeError, ValueError):
                            return default

                    tipo = get_int("tipo", 0) #Primero leo el tipo de enemigo

                    # Calcular spawnX y spawnY a partir de la posici√≥n del objeto enemigo en Tiled
                    # Tiled usa la esquina inferior izquierda (por defecto), as√≠ que restamos la altura para obtener la esquina superior izquierda
                    try:
                        spawn_x_px = float(obj.get("x", 0))
                        spawn_y_px = float(obj.get("y", 0)) - 1
                        
                        if tipo == 255:
                            spawn_y_px += 1
                    except Exception:
                        spawn_x_px, spawn_y_px = 0, 0

                    # Convertimos a coordenadas de tile (ajusta TILE_SIZE si es distinto)
                    spawnX = int(spawn_x_px // TILE_SIZE) % 256
                    spawnY = int(spawn_y_px // TILE_SIZE) % 256


                    # Propiedades enemigo
                    
                    velX, velY, pantalla, vida, sprite = 0,0,0,0,0
                    
                    #Si no es 255 (que sirve para posicionamiento del player)
                    if tipo < 255: 
                        velX        = get_int("velocidad_x", 0)
                        velY        = get_int("velocidad_y", 0)
                        pantalla    = get_int("num_pantalla", 0)
                        vida        = get_int("enem_life", 0)
                        sprite      = get_int("sprite", 0)

                    # Si ahora usas referencias de tipo objeto: limitA / limitB
                    # Estas propiedades en Tiled (tipo "object") guardan el ID del objeto referenciado.
                    limitA_id = get_int("limitA", -1)
                    limitB_id = get_int("limitB", -1)

                    limit1X, limit1Y, limit2X, limit2Y = 0,0,0,0 #seteamos a cero todas
                    if limitA_id in markers:
                        lx, ly = markers[limitA_id]
                        limit1X, limit1Y = lx, ly
                    if limitB_id in markers:
                        lx, ly = markers[limitB_id]
                        limit2X, limit2Y = lx, ly

                    # Empaquetado en el orden requerido
                    data_tuple = (
                        spawnX, spawnY,
                        limit1X, limit1Y,
                        limit2X, limit2Y,
                        velX, velY,
                        tipo, pantalla,
                        vida, sprite
                    )

                    # Conversi√≥n a uint8 con m√≥dulo 256 (permite negativos p.ej. velocidades)
                    clean_tuple = tuple(int(v) % 256 for v in data_tuple)

                    f.write(struct.pack("12B", *clean_tuple))
                    enemy_count += 1

                # Escribir el n√∫mero de enemigos al principio
                f.seek(0)
                f.write(struct.pack("B", enemy_count))

            print(f"üëæ Enemies BIN guardado: {enemies_bin_path} ({enemy_count} enemigos)")

    print(t["console_done"])
    messagebox.showinfo("OK", t["console_done"])


# ---------------- GUI ----------------
class TMXProcessorGUI:
    def __init__(self, root):
        self.root = root
        self.config = load_config()
        self.lang = self.config.get("lang", "es")
        self.root.title(self.t("title"))
        self.root.minsize(620, 370)

        # --- Selector de idioma ---
        lang_frame = tk.Frame(root)
        lang_frame.pack(anchor="ne", padx=10, pady=5)
        es_btn = tk.Button(lang_frame, text="ES", command=lambda: self.set_lang("es"))
        en_btn = tk.Button(lang_frame, text="EN", command=lambda: self.set_lang("en"))
        es_btn.pack(side="left", padx=2)
        en_btn.pack(side="left", padx=2)

        # --- Carpetas ---
        self.src_title = tk.Label(root, text=self.t("src_label"))
        self.src_title.pack(anchor="w", padx=10, pady=(5,0))
        self.src_label, self.src_button = self._path_selector(self.config["source_path"], self.choose_source_path)

        self.bin_title = tk.Label(root, text=self.t("bin_label"))
        self.bin_title.pack(anchor="w", padx=10, pady=(5,0))
        self.bin_label, self.bin_button = self._path_selector(self.config["bin_path"], self.choose_bin_path)

        # --- MAP ---
        self.generate_map_var = tk.BooleanVar(value=self.config["generate_csv"])
        self.map_check = tk.Checkbutton(root, text=self.t("map_check"),
                                        variable=self.generate_map_var, command=self.toggle_map)
        self.map_check.pack(anchor="w", padx=10, pady=(5,0))
        self.map_label, self.map_button = self._path_selector(self.config["csv_path"], self.choose_map_path,
                                                              state="normal" if self.generate_map_var.get() else "disabled")

        # --- Botones finales ---
        btn_frame = tk.Frame(root)
        btn_frame.pack(fill="x", pady=15)
        self.process_btn = tk.Button(btn_frame, text=self.t("process_btn"), command=self.run_processing)
        self.process_btn.pack(side="left", padx=5)
        self.exit_btn = tk.Button(btn_frame, text=self.t("exit_btn"), command=root.quit)
        self.exit_btn.pack(side="left", padx=5)
        self.help_btn = tk.Button(btn_frame, text=self.t("help_btn"), command=self.show_help)
        self.help_btn.pack(side="right", padx=5)

    # --------- Helpers GUI ----------
    def t(self, key):
        return TEXTS[self.lang].get(key, key)

    def set_lang(self, lang):
        self.lang = lang
        self.config["lang"] = lang
        save_config(self.config)
        self.refresh_texts()

    def refresh_texts(self):
        self.root.title(self.t("title"))
        self.src_title.config(text=self.t("src_label"))
        self.bin_title.config(text=self.t("bin_label"))
        self.map_check.config(text=self.t("map_check"))
        self.process_btn.config(text=self.t("process_btn"))
        self.exit_btn.config(text=self.t("exit_btn"))
        self.help_btn.config(text=self.t("help_btn"))
        self.src_button.config(text=self.t("choose"))
        self.bin_button.config(text=self.t("choose"))
        self.map_button.config(text=self.t("choose"))

    def _path_selector(self, initial_path, choose_callback, state="normal"):
        frame = tk.Frame(self.root)
        frame.pack(fill="x", padx=10)
        btn = tk.Button(frame, text=self.t("choose"), command=choose_callback, state=state)
        btn.pack(side="left")
        label = tk.Label(frame, text=self.short_path(initial_path), fg="blue")
        label.pack(side="left", padx=10)
        self.add_tooltip(label, initial_path)
        return label, btn

    def short_path(self, path):
        if not path:
            return self.t("tooltip_empty")
        norm = os.path.normpath(path)
        parts = norm.split(os.sep)
        if len(parts) > 3:
            return "..." + os.sep + os.path.join(*parts[-3:])
        else:
            return norm

    def add_tooltip(self, widget, text):
        if not text:
            return
        tooltip = tk.Toplevel(widget)
        tooltip.withdraw()
        tooltip.overrideredirect(True)
        tooltip_label = tk.Label(tooltip, text=text, bg="#ffffe0", relief="solid", borderwidth=1, padx=4, pady=2)
        tooltip_label.pack()

        def enter(event):
            tooltip_label.config(text=text)
            tooltip.deiconify()
            x = event.x_root + 10
            y = event.y_root + 10
            tooltip.geometry(f"+{x}+{y}")

        def leave(event):
            tooltip.withdraw()

        widget.bind("<Enter>", enter)
        widget.bind("<Leave>", leave)

    # --- Carpeta handlers ---
    def choose_source_path(self):
        folder = filedialog.askdirectory(title=self.t("src_label"))
        if folder:
            self.config["source_path"] = folder
            self.src_label.config(text=self.short_path(folder))
            self.add_tooltip(self.src_label, folder)
            save_config(self.config)

    def choose_bin_path(self):
        folder = filedialog.askdirectory(title=self.t("bin_label"))
        if folder:
            self.config["bin_path"] = folder
            self.bin_label.config(text=self.short_path(folder))
            self.add_tooltip(self.bin_label, folder)
            save_config(self.config)

    def choose_map_path(self):
        folder = filedialog.askdirectory(title="MAP folder")
        if folder:
            self.config["csv_path"] = folder
            self.map_label.config(text=self.short_path(folder))
            self.add_tooltip(self.map_label, folder)
            save_config(self.config)

    def toggle_map(self):
        enabled = self.generate_map_var.get()
        self.map_button.config(state="normal" if enabled else "disabled")
        if enabled:
            stored_path = self.config.get("csv_path", "").strip()
            if stored_path:
                self.map_label.config(text=self.short_path(stored_path))
                self.add_tooltip(self.map_label, stored_path)
            else:
                self.map_label.config(text=self.t("tooltip_empty"))
        else:
            self.map_label.config(text=self.t("tooltip_empty"))
        self.config["generate_csv"] = enabled
        save_config(self.config)

    def run_processing(self):
        source_path = self.config["source_path"].strip()
        bin_path = self.config["bin_path"].strip()
        generate_map = self.generate_map_var.get()
        map_path = self.config["csv_path"].strip() if generate_map else None

        if not source_path:
            messagebox.showerror("Error", self.t("no_src"))
            return
        if not bin_path:
            messagebox.showerror("Error", self.t("no_bin"))
            return
        if generate_map and not map_path:
            messagebox.showerror("Error", self.t("no_map"))
            return

        self.config["generate_csv"] = generate_map
        save_config(self.config)

        process_tmx_folder(source_path, bin_path, map_path, generate_map, self.lang)

    def show_help(self):
        messagebox.showinfo(self.t("help_title"), self.t("help_text"))

# ---------------- MAIN ----------------
if __name__ == "__main__":
    root = tk.Tk()
    app = TMXProcessorGUI(root)
    root.mainloop()
